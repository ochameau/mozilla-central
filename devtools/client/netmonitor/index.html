<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
<!DOCTYPE html>
<html dir="">
  <head>
    <link rel="stylesheet" href="chrome://devtools/content/shared/widgets/widgets.css"/>
    <link rel="stylesheet" href="chrome://devtools/skin/widgets.css"/>
    <link rel="stylesheet" href="chrome://devtools/skin/netmonitor.css"/>
    <script src="chrome://devtools/content/shared/theme-switching.js"></script>
  </head>
  <body class="theme-sidebar" role="application">
    <div id="mount"></div>
    <script>
      "use strict";

      const { BrowserLoader } = Components.utils.import("resource://devtools/client/shared/browser-loader.js", {});
      const require = window.windowRequire = BrowserLoader({
        baseURI: "resource://devtools/client/netmonitor/",
        window,
      }).require;

      const EventEmitter = require("devtools/shared/event-emitter");
      const { createFactory } = require("devtools/client/shared/vendor/react");
      const { render, unmountComponentAtNode } = require("devtools/client/shared/vendor/react-dom");
      const Provider = createFactory(require("devtools/client/shared/vendor/react-redux").Provider);
      const { bindActionCreators } = require("devtools/client/shared/vendor/redux");
      const { configureStore } = require("./src/utils/create-store");
      const store = window.gStore = configureStore();
      const actions = bindActionCreators(require("./src/actions/index"), store.dispatch);
      const { NetMonitorController } = require("./src/netmonitor-controller");

      // Inject EventEmitter into global window.
      EventEmitter.decorate(window);

      window.Netmonitor = {
        bootstrap({ toolbox }) {
          this.mount = document.querySelector("#mount");
          const App = createFactory(require("./src/components/app"));
          render(Provider({ store }, App()), this.mount);
          return NetMonitorController.startupNetMonitor({
            tabConnection: {
              tabTarget: toolbox.target,
            },
            toolbox,
          }, actions);
        },

        destroy() {
          unmountComponentAtNode(this.mount);
          return NetMonitorController.shutdownNetMonitor();
        }
      };

      const {Task} = require("devtools/shared/task");
      const Services = require("Services");
      /**
       * Create a fake toolbox when running the netmonitor standalone, either in a chrome tab or
       * in a content tab.
       *
       * @param {Target} target to debug
       * @param {Function} createThreadClient
       *        When supported the thread client needs a reference to the toolbox.
       *        This callback will be called right after the toolbox object is created.
       * @param {Object} dependencies
       *        - react
       *        - reactDOM
       *        - browserRequire
       */
      const buildFakeToolbox = Task.async(function* (
        target, createThreadClient, {
          React,
          ReactDOM,
          browserRequire
        }) {
        const { InspectorFront } = require("devtools/shared/fronts/inspector");
        const { Selection } = require("devtools/client/framework/selection");
        const { getHighlighterUtils } = require("devtools/client/framework/toolbox-highlighter-utils");

        let notImplemented = function () {
          throw new Error("Not implemented in a tab");
        };
        let fakeToolbox = {
          target,
          hostType: "bottom",
          doc: window.document,
          win: window,
          on() {}, emit() {}, off() {},
          initInspector() {},
          browserRequire,
          React,
          ReactDOM,
          isToolRegistered() {
            return false;
          },
          currentToolId: "inspector",
          getCurrentPanel() {
            return "inspector";
          },
          get textboxContextMenuPopup() {
            notImplemented();
          },
          getPanel: notImplemented,
          openSplitConsole: notImplemented,
          viewCssSourceInStyleEditor: notImplemented,
          viewJsSourceInDebugger: notImplemented,
          viewSource: notImplemented,
          viewSourceInDebugger: notImplemented,
          viewSourceInStyleEditor: notImplemented,

          // For attachThread:
          highlightTool() {},
          unhighlightTool() {},
          selectTool() {},
          raise() {},
          getNotificationBox() {}
        };

        fakeToolbox.threadClient = yield createThreadClient(fakeToolbox);

        let inspector = InspectorFront(target.client, target.form);
        let showAllAnonymousContent =
          Services.prefs.getBoolPref("devtools.inspector.showAllAnonymousContent");
        let walker = yield inspector.getWalker({ showAllAnonymousContent });
        let selection = new Selection(walker);
        let highlighter = yield inspector.getHighlighter(false);
        fakeToolbox.highlighterUtils = getHighlighterUtils(fakeToolbox);

        fakeToolbox.inspector = inspector;
        fakeToolbox.walker = walker;
        fakeToolbox.selection = selection;
        fakeToolbox.highlighter = highlighter;
        return fakeToolbox;
      });

      // URL constructor doesn't support chrome: scheme
      let href = window.location.href.replace(/chrome:/, "http://");
      let url = new window.URL(href);

      // If query parameters are given in a chrome tab, the inspector is running in standalone.
      if (window.location.protocol === "chrome:" && url.search.length > 1) {
        const { targetFromURL } = require("devtools/client/framework/target-from-url");
        const { attachThread } = require("devtools/client/framework/attach-thread");

        const browserRequire = BrowserLoader({ window, useOnlyShared: true }).require;
        const React = browserRequire("devtools/client/shared/vendor/react");
        const ReactDOM = browserRequire("devtools/client/shared/vendor/react-dom");

        Task.spawn(function* () {
          let target = yield targetFromURL(url);
          let fakeToolbox = yield buildFakeToolbox(
            target,
            (toolbox) => attachThread(toolbox),
            { React, ReactDOM, browserRequire }
          );
          // Start the network event listening as it is done in the toolbox code
          yield target.activeConsole.startListeners([
            "NetworkActivity",
          ]);
          Netmonitor.bootstrap({ toolbox: fakeToolbox });
        }).then(null, e => {
          window.alert("Unable to start the inspector:" + e.message + "\n" + e.stack);
        });
      }
    </script>
  </body>
</html>
